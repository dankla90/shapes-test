"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizedToAbsoluteNode = exports.normalizedToAbsolute = exports.absoluteNodeToStatements = exports.isEmptyValue = exports.safeNode = exports.absoluteToStatements = exports.oldFromNewStatements = exports.deleteStatementsForEmptyValues = exports.dataToStatements = void 0;
var rdflib_1 = require("rdflib");
var xml = rdflib_1.Namespace("http://www.w3.org/2001/XMLSchema#");
function dataToStatements(shape, data, doc) {
    var absoluteData = normalizedToAbsolute(data, __spreadArray([shape.context], shape.childContexts), shape.prefixes);
    var ins = absoluteToStatements(shape.store, absoluteData, doc).filter(function (_a) {
        var subject = _a.subject, predicate = _a.predicate, object = _a.object, graph = _a.graph;
        return shape.store.statementsMatching(subject, predicate, object, graph)
            .length === 0;
    });
    var delEmptyValues = deleteStatementsForEmptyValues(shape.store, absoluteData, doc);
    var delOldValues = oldFromNewStatements(shape.store, ins);
    var del = __spreadArray(__spreadArray([], delOldValues), delEmptyValues);
    return [del, ins];
}
exports.dataToStatements = dataToStatements;
function deleteStatementsForEmptyValues(store, data, doc) {
    var id = data.id;
    return Object.keys(data).reduce(function (allDelStatements, key) {
        if (isEmptyValue(data[key])) {
            var nodeToDelete = store.any(safeNode(doc, id), new rdflib_1.NamedNode(key), null, new rdflib_1.NamedNode(doc).doc());
            if (nodeToDelete) {
                return __spreadArray(__spreadArray(__spreadArray([], allDelStatements), store.statementsMatching(nodeToDelete)), store.statementsMatching(null, null, nodeToDelete));
            }
            else {
                return allDelStatements;
            }
        }
        else {
            return allDelStatements;
        }
    }, []);
}
exports.deleteStatementsForEmptyValues = deleteStatementsForEmptyValues;
function oldFromNewStatements(store, ins) {
    var oldStatements = ins.reduce(function (allDelStatements, st) {
        var oldStatements = store.statementsMatching(st.subject, st.predicate, null, st.graph);
        return oldStatements.length > 0
            ? __spreadArray(__spreadArray([], allDelStatements), oldStatements) : allDelStatements;
    }, []);
    return oldStatements.filter(function (oldSt, index, statements) {
        return (!ins.find(function (st) { return JSON.stringify(st) === JSON.stringify(oldSt); }) &&
            statements.findIndex(function (st) { return JSON.stringify(st) === JSON.stringify(oldSt); }) === index);
    });
}
exports.oldFromNewStatements = oldFromNewStatements;
function absoluteToStatements(store, data, doc) {
    var id = data.id, props = __rest(data, ["id"]);
    var statements = Object.keys(props).reduce(function (statements, prop) {
        var value = props[prop];
        var statement = absoluteNodeToStatements(store, id, prop, value, doc);
        if (Array.isArray(statement)) {
            return __spreadArray(__spreadArray([], statements), statement);
        }
        else {
            return __spreadArray(__spreadArray([], statements), [statement]);
        }
    }, []);
    return statements.filter(function (newSt, index, statements) {
        return (statements.findIndex(function (st) { return JSON.stringify(st) === JSON.stringify(newSt); }) === index);
    });
}
exports.absoluteToStatements = absoluteToStatements;
function safeNode(doc, id) {
    var _a, _b;
    var subject;
    if (((_a = id) === null || _a === void 0 ? void 0 : _a.termType) && ((_b = id) === null || _b === void 0 ? void 0 : _b.value))
        return id;
    if (!id) {
        var newNode = new URL(doc);
        newNode.hash = "id" + new Number(new Date());
        return new rdflib_1.NamedNode(newNode.toString());
    }
    try {
        subject = new rdflib_1.NamedNode(id);
    }
    catch (_c) {
        var newNode = new URL(doc);
        newNode.hash = "id" + new Number(new Date());
        subject = new rdflib_1.NamedNode(newNode.toString());
    }
    return subject;
}
exports.safeNode = safeNode;
function isEmptyValue(obj) {
    return ((!obj && typeof obj !== "number") ||
        (typeof obj === "object" &&
            typeof obj.toISOString !== "function" &&
            typeof obj.href !== "string" &&
            Object.values(obj).filter(function (value) { return !isEmptyValue(value); })
                .length === 0));
}
exports.isEmptyValue = isEmptyValue;
function absoluteNodeToStatements(store, id, prop, value, doc) {
    var _a;
    var isNode = (value === null || value === void 0 ? void 0 : value.termType) === "NamedNode" ||
        (value === null || value === void 0 ? void 0 : value.termType) === "BlankNode" ||
        (value === null || value === void 0 ? void 0 : value.termType) === "Literal";
    if (isEmptyValue(value)) {
        return [];
    }
    if (typeof value !== "object" || isNode) {
        var valueNode = void 0;
        if (isNode) {
            valueNode = value;
        }
        else {
            try {
                valueNode = new rdflib_1.NamedNode(value);
            }
            catch (_b) {
                valueNode = new rdflib_1.Literal(value);
            }
        }
        return new rdflib_1.Statement(safeNode(doc, id), new rdflib_1.NamedNode(prop), valueNode, new rdflib_1.NamedNode(doc).doc());
    }
    else if (Array.isArray(value)) {
        return value.reduce(function (allStatements, value) {
            var statements = absoluteToStatements(store, __assign({ id: id }, value), doc);
            return __spreadArray(__spreadArray([], allStatements), statements);
        }, []);
    }
    else {
        if (typeof value.toISOString === "function") {
            return new rdflib_1.Statement(new rdflib_1.NamedNode(id), new rdflib_1.NamedNode(prop), new rdflib_1.Literal(value.toISOString(), null, xml("dateTime")), new rdflib_1.NamedNode(doc).doc());
        }
        else if (typeof value.href === "string") {
            return new rdflib_1.Statement(new rdflib_1.NamedNode(id), new rdflib_1.NamedNode(prop), new rdflib_1.NamedNode(value.href), new rdflib_1.NamedNode(doc).doc());
        }
        else {
            var targetNode = safeNode(doc, id);
            var newOrExistingNode = (_a = store.any(targetNode, new rdflib_1.NamedNode(prop), null)) !== null && _a !== void 0 ? _a : safeNode(doc, value.id);
            if (newOrExistingNode.termType === "BlankNode") {
                newOrExistingNode = safeNode(doc, value.id);
            }
            return __spreadArray([
                new rdflib_1.Statement(new rdflib_1.NamedNode(id), new rdflib_1.NamedNode(prop), newOrExistingNode, new rdflib_1.NamedNode(doc).doc())
            ], absoluteToStatements(store, __assign(__assign({}, value), { id: newOrExistingNode }), doc));
        }
    }
}
exports.absoluteNodeToStatements = absoluteNodeToStatements;
function normalizedToAbsolute(data, contexts, prefixes) {
    var absoluteData = {};
    Object.keys(data).map(function (key) {
        var _a;
        if (Array.isArray(data[key])) {
            var absoluteNodes = data[key].map(function (value) {
                return normalizedToAbsoluteNode(key, value, contexts, prefixes);
            });
            var absoluteKey = Object.keys(absoluteNodes)[0];
            absoluteData = __assign(__assign({}, absoluteData), (_a = {}, _a[absoluteKey] = Object.values(absoluteNodes), _a));
        }
        else {
            absoluteData = __assign(__assign({}, absoluteData), normalizedToAbsoluteNode(key, data[key], contexts, prefixes));
        }
    });
    return absoluteData;
}
exports.normalizedToAbsolute = normalizedToAbsolute;
function normalizedToAbsoluteNode(key, nodeValue, contexts, prefixes) {
    var _a, _b;
    var _c;
    if (key === "id") {
        return { id: nodeValue };
    }
    var contextKey = ((_c = contexts.find(function (context) { return context[key]; })) !== null && _c !== void 0 ? _c : {})[key];
    if (!contextKey)
        throw new Error("Key: " +
            key +
            " could not be found in context: " +
            JSON.stringify(contexts));
    var prefix = contextKey.split(":")[0];
    var absoluteKey = prefixes[prefix] + key;
    if (typeof nodeValue === "object" &&
        !nodeValue.toISOString &&
        !nodeValue.href &&
        !((nodeValue === null || nodeValue === void 0 ? void 0 : nodeValue.termType) && nodeValue.value)) {
        return _a = {},
            _a[absoluteKey] = normalizedToAbsolute(nodeValue, contexts, prefixes),
            _a;
    }
    else {
        return _b = {}, _b[absoluteKey] = nodeValue, _b;
    }
}
exports.normalizedToAbsoluteNode = normalizedToAbsoluteNode;
//# sourceMappingURL=dataToRdf.js.map
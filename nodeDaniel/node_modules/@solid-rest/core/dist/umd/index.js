(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "./examineRequest.js", "./examineRequestedItem.js", "./handleRequest.js", "./performRequestedMethod.js", "./handleResponse.js", "./utils/utils.js", "./utils/container.js", "./utils/rest-patch.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("./examineRequest.js"), require("./examineRequestedItem.js"), require("./handleRequest.js"), require("./performRequestedMethod.js"), require("./handleResponse.js"), require("./utils/utils.js"), require("./utils/container.js"), require("./utils/rest-patch.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.examineRequest, global.examineRequestedItem, global.handleRequest, global.performRequestedMethod, global.handleResponse, global.utils, global.container, global.restPatch);
    global.index = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _examineRequest, _examineRequestedItem, _handleRequest, _performRequestedMethod, _handleResponse, _utils, _container, _restPatch) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _performRequestedMethod = _interopRequireDefault(_performRequestedMethod);
  _container = _interopRequireDefault(_container);
  _restPatch = _interopRequireDefault(_restPatch);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class SolidRest {
    constructor(options) {
      options = options || {};

      if (!options.plugin) {
        console.log(`You must specify a plugin storage handler!`);
        process.exit(1);
      }

      this.storage = options.plugin;
      this.handleRequest = _handleRequest.handleRequest.bind(this);
      this.handleResponse = _handleResponse.handleResponse.bind(this);
      this.getItem = _examineRequestedItem.getItem.bind(this);
      this.getRequest = _examineRequest.getRequest.bind(this);
      this.perform = _performRequestedMethod.default.bind(this);
      this.isAuxResource = _utils.isAuxResource.bind(this);
      this.getAuxResources = _utils.getAuxResources.bind(this);
      this.getContentType = this.storage.getContentType.bind(this.storage);
      this.generateRandomSlug = _utils.generateRandomSlug.bind(this);
      this.createServerlessPod = _utils.createServerlessPod.bind(this);
      if (this.storage.configFetcher) this.configFetcher = this.storage.configFetcher.bind(this.storage);
      if (this.storage.configure) this.configure = this.storage.configure.bind(this.storage);
      this.containerAsTurtle = _container.default.bind(this);
      let $rdf = options.parser ? options.parser : typeof window != "undefined" && window.$rdf ? window.$rdf : typeof global != "undefined" && global.$rdf ? global.$rdf : null;
      this.patch = options.patch = $rdf ? new _restPatch.default($rdf) : null;
    }

    async fetch(uri, options = {}) {
      let response = await this.handleRequest(uri, options);
      return await this.handleResponse(response, options);
    }

    async login(options) {
      options = {
        loginOptions: options,
        method: 'login'
      };
      let response = await this.handleRequest('http://example.org/', options);
      return await this.handleResponse(response, options);
    }

    async itemExists(pathname) {
      return await this.perform('ITEM_EXISTS', pathname);
    }

    isPatchConflictError(response) {
      if (response === 400) return true;
    }

    isAccessError(response) {
      if (response === 401) return true;
    }
    /* =========================================================== */

    /* REST METHODS                                                */

    /* =========================================================== */


    async GET(url) {
      return await this.fetch(url, {
        method: "GET"
      });
    }

    async HEAD(url) {
      return await this.fetch(url, {
        method: "HEAD"
      });
    }

    async EXISTS(url) {
      try {
        let res = await this.fetch(url, {
          method: "HEAD"
        });
        return res.status == 200 ? true : false;
      } catch (e) {
        return false;
      }
    }

    async PUT(url, text, ctype) {
      ctype = ctype || 'text/turtle';
      return await this.fetch(url, {
        method: "PUT",
        body: text,
        headers: {
          "content-type": ctype
        }
      });
    }

    async PATCH(url, patchContent, patchContentType) {
      patchContentType = patchContent || "text/n3";
      return await this.fetch(url, {
        method: 'PATCH',
        body: patchContent,
        headers: {
          'Content-Type': patchContentType,
          link: '<http://www.w3.org/ns/ldp#Resource>; rel="type"'
        },
        relative: true
      });
    }

    async DELETE(url) {
      return await this.fetch(url, {
        method: "DELETE"
      });
    }

    async POST(parent, item, content, link) {
      return await this.fetch(parent, {
        method: "POST",
        headers: {
          slug: item,
          link: link,
          "content-type": "text/turtle"
        },
        body: content
      });
    }

    async postFile(parent, file, content) {
      let link = '<http://www.w3.org/ns/ldp#Resource>; rel="type"';
      return POST(parent, file, content, link);
    }

    async postFolder(parent, folder) {
      let link = '<http://www.w3.org/ns/ldp#BasicContainer>; rel="type"';
      return POST(parent, folder, '', link);
    }

  } // THE END


  _exports.default = SolidRest;
});